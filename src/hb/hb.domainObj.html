<link rel="import" href="hb.html">
<link rel="import" href="ProgressTracker.html">
<script>
/**
 * Base class for all domain objects.
 */
hb.DomainObj  = class {
    static get is() { 
        throw new Error("doc.is not defined");
    }

    constructor({db, dbPath}) {
        this.db = db;
        this.dbPath = dbPath;
        this.docRef = db.doc(dbPath);
        
        // [{add: true, event, dbPath, is, scope}]
        this._listenersToHandle = [];
        
        //[event-name]
        this._eventsToHandle = [];
    }
    
    /**
     * Supports api method updates
     * @param update
     * A method that recieves its document which can make changes to
     * and return the document.
     * The method can make calls to dispatchEvent, addEventListener, and  removeEventListener.
     * @param progressTracker
     * An optional ProgressTracker to listen for the progress of the update.
     * @returns Object
     * The document data to update.
     * If the return value is falsy, no updates will occur.
     */
    update(update, progressTracker = new ProgressTracker()) {
        var progressLayer = progressTracker.addLayer("Update", 5);
        progressLayer.next("Loading document");
        
        return this.docRef.get().then(event => {
            progressLayer.next("Updating");

            const doc = event.data();
            let newDoc = update(doc);
           
            newDoc = this._updateReferences(newDoc);
            if (!newDoc) {
                progressLayer.done("No updates needed");
                return Promise.resolve();
            }

            this.docRef.update(newDoc).then(_ => {
                progressLayer.next("Updating references");
                return this._updateReferencedBy(newDoc);
            }).then(doc => {
                progressLayer.next("Dispatching events");
                return this._dispatchEvents(doc)
            }).then(_ => {
                progressLayer.done("Document updated");
            }).catch(error => {
                progressLayer.error(error);
            });          
        });
    }

    /**
     * A syncronous method which adds or removes
     * references using _listenersToHandle
     * @param doc
     * The document to update.
     * @returns Object - The updated doc.
     */
    _updateReferences(doc) {
        // _listenersToHandle: [{add: true, event, dbPath, is, scope}]
        // references: {
        //     "doc/gallery-1": {
        //         is: "hb-art-gallery-doc",
        //         events: {
        //             "": ["description-changed"]
        //             "artwork": ["thumbnail-changed"]
        //         }
        //     }
        // }
        doc.references = doc.references || {};

        const addListener = (listener) => {
            const reference = doc.references[listener.dbPath] || {};
            const events = reference.events || {};
            const scopeName = listener.scope || "";
            const scope = events[scopeName] || [];
            // make sure the event is added just once
            if (scope.includes(listener.event) === false) {
                scope.push(listener.event);        
            }
            // rebuild the reference
            events[scopeName] = scope;
            reference.is = listener.is;                
            reference.events = events;                
            doc.references[listener.dbPath] = reference;
        };

        const removeListener = (listener) => {
            const reference = doc.references[listener.dbPath];
            if (!reference) {
                return;
            }
            // if event is null, remove all for the dbPath
            if (!listener.event) {
                delete doc.references[listener.dbPath];
            // remove the specified event
            } else if (reference.events) {
                const scope = reference.events[listener.scope || ""];
                if (scope) {
                    scope.splice(scope.indexOf(listener.event), 1);
                }
            }
        };

        this._listenersToHandle.forEach(listener => {
            if (listener.add === true) {               
                addListener(listener);
            } else if (listener.remove === true) {
                removeListener(listener);   
            }
        });
        return doc;
    }

    _updateReferencedBy(doc) {
        // needs to be a promise
        // load all objects and add references to them
        // then clear the _listenersToHandle
        // return the new doc
    }

    /**
     * Matches any events in this._eventsToHandle to items in the referencedBy
     * For every document, load the DomainObj and then call handle events on that DomainObj.
     */
    _dispatchEvents(doc) {
        if (!doc.referencedBy) {
            return Promise.resolve();
        }

        // notify objects of a reference change
        Object.keys(doc.referencedBy).forEach(key => {
            const reference = doc.referencedBy[key];
            const staticDomainObj = hb[reference.is];
            const domainObjEvents = staticDomainObj.events;


            // if the doc does not exist then remove the reference

            // test first if the document has anything to update

            // if reference.events.keys match any domainObjEvents then we need to load that document
            const docRef = this.db.doc(key);
            const domainObj = new hb[reference.is](this.db);
            docRef.get(event => {
                const referenceDoc = event.data();
                // call each event handler -> which could add to _eventsToHandle
                domainObj[handler](doc);
                // now domainObj may have _eventsToHandle

                // this means this method should be on the document handleEvents OR _handleEvents
                docRef.update(referenceDoc);

            });
            // after all events are fired call
            // domainObj._handleEvents();


        });        
    }

    /**
     * Loads the doc then calls the event handlers for each event.
     * The handlers return the new doc if they require an update.
     * If an update is required, save the doc and then call _dispatchEvents.
     * @param events
     * The key is the scope and the value is an array of
     * events to listen for.
     * {
	 *   "": ["description-changed"]
	 *	 "artwork": ["thumbnail-changed"]
	 *	}
     */
    _handleEvents(refDoc, events) {
        this.docRef.get().then(event => {
            const doc = event.data();

            // for each event call the handler
            // if there is a change then
            // save the doc and then call _dispatchEvents
        });
    }

    dispatchEvent(event) {
        this._eventsToHandle.push(event);
    }

    addEventListener(event, dbPath, is, scope) {
        this._listenersToHandle.push({add: true, event, dbPath, is, scope});
    }

    removeEventListener(event, dbPath, scope) {
        this._listenersToHandle.push({remove: true, event, dbPath, scope});
    }
}
</script>