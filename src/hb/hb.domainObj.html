<link rel="import" href="hb.html">
<link rel="import" href="ProgressTracker.html">
<script>
/**
 * Base class for all domain objects.
 */
hb.DomainObj  = class {
    static get is() { 
        throw new Error("doc.is not defined");
    }

    constructor({db, dbPath}) {
        this.db = db;
        this.dbPath = dbPath;
        this.docRef = db.doc(dbPath);
        
        // [{add: true, event, dbPath, is, scope}]
        this._listenersToHandle = [];
        
        //[event-name]
        this._eventsToHandle = [];
    }
    
    /**
     * Supports api method updates
     * @param update
     * A method that recieves its document which can make changes to
     * and return the document.
     * The method can make calls to dispatchEvent, addEventListener, and  removeEventListener.
     * @param progressTracker
     * An optional ProgressTracker to listen for the progress of the update.
     * @returns Object
     * The document data to update.
     * If the return value is falsy, no updates will occur.
     */
    update(update, progressTracker = new ProgressTracker()) {
        var progressLayer = progressTracker.addLayer("Update", 5);
        progressLayer.next("Loading document");
        
        return this.docRef.get().then(event => {
            progressLayer.next("Updating");

            const doc = event.data();
            let newDoc = update(doc);
           
            newDoc = this._updateReferences(newDoc);
            if (!newDoc) {
                progressLayer.done("No updates needed");
                return Promise.resolve();
            }

            this.docRef.update(newDoc).then(_ => {
                progressLayer.next("Updating references");
                return this._updateReferencedBy(newDoc);
            }).then(doc => {
                progressLayer.next("Dispatching events");
                return this._dispatchEvents(doc)
            }).then(_ => {
                progressLayer.done("Document updated");
            }).catch(error => {
                progressLayer.error(error);
            });          
        });
    }

    /**
     * A syncronous method which adds or removes
     * references using _listenersToHandle
     * @param doc
     * The document to update.
     * @returns Object - The updated doc.
     */
    _updateReferences(doc) {
        // _listenersToHandle: [{add: true, event, dbPath, is, scope}]
        // references: {
        //     "doc/gallery-1": {
        //         is: "hb-art-gallery-doc",
        //         events: {
        //             "": ["description-changed"]
        //             "artwork": ["thumbnail-changed"]
        //         }
        //     }
        // }
        doc.references = doc.references || {};

        const addListener = (listener) => {
            const reference = doc.references[listener.dbPath] || {};
            const events = reference.events || {};
            const scopeName = listener.scope || "";
            const scope = events[scopeName] || [];
            // make sure the event is added just once
            if (scope.includes(listener.event) === false) {
                scope.push(listener.event);        
            }
            // rebuild the reference
            events[scopeName] = scope;
            reference.is = listener.is;                
            reference.events = events;                
            doc.references[listener.dbPath] = reference;
        };

        const removeListener = (listener) => {
            const reference = doc.references[listener.dbPath];
            if (!reference) {
                return;
            }
            // if event is null, remove all for the dbPath
            if (!listener.event) {
                delete doc.references[listener.dbPath];
            // remove the specified event
            } else if (reference.events) {
                const scope = reference.events[listener.scope || ""];
                if (scope) {
                    scope.splice(scope.indexOf(listener.event), 1);
                }
            }
        };

        this._listenersToHandle.forEach(listener => {
            if (listener.add === true) {               
                addListener(listener);
            } else if (listener.remove === true) {
                removeListener(listener);   
            }
        });
        return doc;
    }

    _updateReferencedBy(doc) {
        // needs to be a promise
        // load all objects and add references to them
        // then clear the _listenersToHandle
        // return the new doc
    }

    /**
     * For every referencedBy entry, create the DomainObj
     * and then call _handleEvents on that DomainObj.
     * @param doc the data for this domainObj
     * @returns Promise
     */
    _dispatchEvents(doc) {
        if (!doc.referencedBy) {
            return Promise.resolve();
        }

        // notify objects of a reference change
        const promises = Object.keys(doc.referencedBy).map(dbPath => {
            const reference = doc.referencedBy[dbPath];
            const eventHandlers = hb[reference.is].events;
            const eventsToHandle = reference.events;

            if (!eventHandlers || !eventsToHandle) {
                return Promise.resolve();
            }

            const domainObj = new hb[reference.is]({db: this.db, dbPath});
            return domainObj._handleEvents({eventHandlers, eventsToHandle, refDoc: doc});
        });
        return Promise.all(promises);
    }

    /**
     * See if there are any methods to call.
     * If so, load the doc from the db and call each method.
     * If any handler returns a new doc it doc will updated / saved.
     * If an update is required, then call _dispatchEvents.
     * @param eventHandlers the statically declared handlers on this domainObj
     * Example:
     * {
	 *   "some-event":  "_someEvent",
	 *   // scoped
	 *   "thumbnail-changed": {
	 *     "": "_someThumbnailChanged",
	 *     "artwork": "_artworkThumbnailChanged"
	 *   }
	 * };
     * @param eventsToHandle the key is the scope and the value is an array of
     * Example:
     * {
	 *   "": ["description-changed"]
	 *   "artwork": ["thumbnail-changed"]
	 * }
     * @param refDoc the document that triggered the events.
     * @returns Promise
     */
    _handleEvents({eventHandlers, eventsToHandle, refDoc}) {

        const methodsToCall = Object.keys(eventsToHandle).reduce((methods, scope) => {
            const events = eventsToHandle[scope];
            events.forEach(eventName => {
                const handler = eventHandlers[eventName];
                if (!handler) {
                    return;
                }

                let method = null;
                if (scope === "" && typeof handler === "string") {
                    method = handler;
                } else if (handler[scope]) {
                   method = handler[scope];
                }
                
                // only add the method to call if it exists on this domainObj
                if (method && this[method]) {
                    methods.push(method);
                }
            });
            return methods;
        }, []);

        if (methodsToCall.length === 0) {
            return Promise.resolve();
        }
        
        // we have methods to call, load the doc and call the methods
        return this.docRef.get().then(event => {
            let doc = event.data();
            const needUpdate = methodsToCall.reduce((needUpdate, method) => {
                const newDoc = this[method](doc, refDoc);
                if (newDoc) {
                    doc = newDoc;
                    needUpdate = true;
                }
                return needUpdate;            
            }, false);
            
            if (needUpdate === false) {
                return Promise.resolve();
            }

            return this.docRef.update(doc).then(_ => {
                //progressLayer.next("Dispatching events");
                return this._dispatchEvents(doc)
            }).then(_ => {
                //progressLayer.done("Document updated");
            }).catch(error => {
                //progressLayer.error(error);
            });
        });
    }

    dispatchEvent(event) {
        this._eventsToHandle.push(event);
    }

    addEventListener(event, dbPath, is, scope) {
        this._listenersToHandle.push({add: true, event, dbPath, is, scope});
    }

    removeEventListener(event, dbPath, scope) {
        this._listenersToHandle.push({remove: true, event, dbPath, scope});
    }
}
</script>